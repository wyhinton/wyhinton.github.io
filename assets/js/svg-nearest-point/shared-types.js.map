{
  "version": 3,
  "sources": ["../../../src/ts/svg-nearest-point/shared-types.ts"],
  "sourcesContent": ["// Shared interfaces and types for SVG nearest point demos\r\n\r\nexport interface Point {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nexport interface SearchResult {\r\n  point: Point;\r\n  distance: number;\r\n  time: number;\r\n  samplesChecked?: number;\r\n  pathIndex?: number;\r\n}\r\n\r\nexport interface QuadTreeSearchResult extends SearchResult {\r\n  candidatesChecked: number;\r\n  searchRadius: number;\r\n}\r\n\r\nexport interface Bounds {\r\n  x: number;\r\n  y: number;\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\nexport interface QuadTreePoint extends Point {\r\n  pathIndex: number;\r\n  t: number;\r\n  path: SVGPathElement;\r\n}\r\n\r\nexport interface QuadTreeChildren {\r\n  nw: QuadTreeNode;\r\n  ne: QuadTreeNode;\r\n  sw: QuadTreeNode;\r\n  se: QuadTreeNode;\r\n}\r\n\r\n// Shared utility functions\r\nexport async function loadSVGPaths(svgUrl: string): Promise<string[]> {\r\n  try {\r\n    const response = await fetch(svgUrl);\r\n    if (!response.ok) {\r\n      throw new Error(`Failed to fetch SVG: ${response.status}`);\r\n    }\r\n    \r\n    const svgText = await response.text();\r\n    const parser = new DOMParser();\r\n    const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');\r\n    \r\n    // Check for parsing errors\r\n    const parseError = svgDoc.querySelector('parsererror');\r\n    if (parseError) {\r\n      throw new Error('Failed to parse SVG');\r\n    }\r\n    \r\n    // Extract all path elements and their 'd' attributes\r\n    const pathElements = svgDoc.querySelectorAll('path');\r\n    const pathData: string[] = [];\r\n    console.log(pathElements)\r\n    \r\n    pathElements.forEach(path => {\r\n      const d = path.getAttribute('d');\r\n      if (d) {\r\n        pathData.push(d);\r\n      }\r\n    });\r\n    \r\n    return pathData;\r\n  } catch (error) {\r\n    console.error('Error loading SVG paths:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n// QuadTree implementation\r\nexport class QuadTreeNode {\r\n  private bounds: Bounds;\r\n  private maxPoints: number;\r\n  private maxDepth: number;\r\n  private depth: number;\r\n  private points: QuadTreePoint[];\r\n  private children: QuadTreeChildren | null;\r\n  private divided: boolean;\r\n\r\n  constructor(bounds: Bounds, maxPoints: number = 20, maxDepth: number = 5, depth: number = 0) {\r\n    this.bounds = bounds;\r\n    this.maxPoints = maxPoints;\r\n    this.maxDepth = maxDepth;\r\n    this.depth = depth;\r\n    this.points = [];\r\n    this.children = null;\r\n    this.divided = false;\r\n  }\r\n\r\n  insert(point: QuadTreePoint): boolean {\r\n    if (!this.contains(point)) return false;\r\n\r\n    if (this.points.length < this.maxPoints || this.depth >= this.maxDepth) {\r\n      this.points.push(point);\r\n      return true;\r\n    }\r\n\r\n    if (!this.divided) {\r\n      this.subdivide();\r\n    }\r\n\r\n    return !!(\r\n      this.children!.nw.insert(point) ||\r\n      this.children!.ne.insert(point) ||\r\n      this.children!.sw.insert(point) ||\r\n      this.children!.se.insert(point)\r\n    );\r\n  }\r\n\r\n  private subdivide(): void {\r\n    const { x, y, width, height } = this.bounds;\r\n    const halfWidth = width / 2;\r\n    const halfHeight = height / 2;\r\n\r\n    this.children = {\r\n      nw: new QuadTreeNode(\r\n        { x, y, width: halfWidth, height: halfHeight },\r\n        this.maxPoints, this.maxDepth, this.depth + 1\r\n      ),\r\n      ne: new QuadTreeNode(\r\n        { x: x + halfWidth, y, width: halfWidth, height: halfHeight },\r\n        this.maxPoints, this.maxDepth, this.depth + 1\r\n      ),\r\n      sw: new QuadTreeNode(\r\n        { x, y: y + halfHeight, width: halfWidth, height: halfHeight },\r\n        this.maxPoints, this.maxDepth, this.depth + 1\r\n      ),\r\n      se: new QuadTreeNode(\r\n        { x: x + halfWidth, y: y + halfHeight, width: halfWidth, height: halfHeight },\r\n        this.maxPoints, this.maxDepth, this.depth + 1\r\n      )\r\n    };\r\n\r\n    this.divided = true;\r\n\r\n    // Redistribute existing points\r\n    for (const point of this.points) {\r\n      this.children.nw.insert(point) ||\r\n      this.children.ne.insert(point) ||\r\n      this.children.sw.insert(point) ||\r\n      this.children.se.insert(point);\r\n    }\r\n    this.points = [];\r\n  }\r\n\r\n  private contains(point: Point): boolean {\r\n    return (\r\n      point.x >= this.bounds.x &&\r\n      point.x < this.bounds.x + this.bounds.width &&\r\n      point.y >= this.bounds.y &&\r\n      point.y < this.bounds.y + this.bounds.height\r\n    );\r\n  }\r\n\r\n  query(range: Bounds, found: QuadTreePoint[] = []): QuadTreePoint[] {\r\n    if (!this.intersects(range)) return found;\r\n\r\n    for (const point of this.points) {\r\n      if (this.pointInRange(point, range)) {\r\n        found.push(point);\r\n      }\r\n    }\r\n\r\n    if (this.divided && this.children) {\r\n      this.children.nw.query(range, found);\r\n      this.children.ne.query(range, found);\r\n      this.children.sw.query(range, found);\r\n      this.children.se.query(range, found);\r\n    }\r\n\r\n    return found;\r\n  }\r\n\r\n  private intersects(range: Bounds): boolean {\r\n    return !(\r\n      range.x > this.bounds.x + this.bounds.width ||\r\n      range.x + range.width < this.bounds.x ||\r\n      range.y > this.bounds.y + this.bounds.height ||\r\n      range.y + range.height < this.bounds.y\r\n    );\r\n  }\r\n\r\n  private pointInRange(point: Point, range: Bounds): boolean {\r\n    return (\r\n      point.x >= range.x &&\r\n      point.x <= range.x + range.width &&\r\n      point.y >= range.y &&\r\n      point.y <= range.y + range.height\r\n    );\r\n  }\r\n\r\n  getAllBounds(): Bounds[] {\r\n    const bounds = [this.bounds];\r\n    if (this.divided && this.children) {\r\n      bounds.push(...this.children.nw.getAllBounds());\r\n      bounds.push(...this.children.ne.getAllBounds());\r\n      bounds.push(...this.children.sw.getAllBounds());\r\n      bounds.push(...this.children.se.getAllBounds());\r\n    }\r\n    return bounds;\r\n  }\r\n}\r\n\r\n// Utility function to center all path elements within an SVG\r\nexport function centerPathsInSVG(svg: SVGSVGElement): void {\r\n  const paths = svg.querySelectorAll('path');\r\n  if (paths.length === 0) return;\r\n\r\n  // Get the SVG dimensions\r\n  const svgRect = svg.getBoundingClientRect();\r\n  const svgWidth = svgRect.width || parseFloat(svg.getAttribute('width') || '800');\r\n  const svgHeight = svgRect.height || parseFloat(svg.getAttribute('height') || '600');\r\n\r\n  // Calculate bounding box of all paths\r\n  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\r\n\r\n  paths.forEach(path => {\r\n    const bbox = path.getBBox();\r\n    minX = Math.min(minX, bbox.x);\r\n    minY = Math.min(minY, bbox.y);\r\n    maxX = Math.max(maxX, bbox.x + bbox.width);\r\n    maxY = Math.max(maxY, bbox.y + bbox.height);\r\n  });\r\n\r\n  // Calculate the center offset needed\r\n  const pathsWidth = maxX - minX;\r\n  const pathsHeight = maxY - minY;\r\n  const pathsCenterX = minX + pathsWidth / 2;\r\n  const pathsCenterY = minY + pathsHeight / 2;\r\n  const svgCenterX = svgWidth / 2;\r\n  const svgCenterY = svgHeight / 2;\r\n\r\n  const offsetX = svgCenterX - pathsCenterX;\r\n  const offsetY = svgCenterY - pathsCenterY;\r\n\r\n  // Apply the transform to center the paths\r\n  if (Math.abs(offsetX) > 0.1 || Math.abs(offsetY) > 0.1) {\r\n    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');\r\n    group.setAttribute('transform', `translate(${offsetX}, ${offsetY})`);\r\n    \r\n    // Move all paths into the group\r\n    const pathsArray = Array.from(paths);\r\n    pathsArray.forEach(path => {\r\n      svg.removeChild(path);\r\n      group.appendChild(path);\r\n    });\r\n    \r\n    svg.appendChild(group);\r\n  }\r\n}\r\n\r\n// Helper function to parse and modify path data\r\nfunction translatePathData(pathData: string, offsetX: number, offsetY: number): string {\r\n  // Simple path parser that handles M, L, H, V, C, S, Q, T, A, Z commands\r\n  // This handles both absolute and relative commands\r\n  return pathData.replace(/([MLHVCSQTAZ])([^MLHVCSQTAZ]*)/gi, (match, command, coords) => {\r\n    const isRelative = command === command.toLowerCase();\r\n    const upperCommand = command.toUpperCase();\r\n    \r\n    if (upperCommand === 'Z') {\r\n      return match; // Z has no coordinates\r\n    }\r\n    \r\n    const numbers = coords.match(/-?\\d*\\.?\\d+/g);\r\n    if (!numbers) return match;\r\n    \r\n    let modifiedNumbers: string[] = [];\r\n    \r\n    switch (upperCommand) {\r\n      case 'M':\r\n      case 'L':\r\n      case 'T':\r\n        // x, y coordinates\r\n        for (let i = 0; i < numbers.length; i += 2) {\r\n          const x = parseFloat(numbers[i]);\r\n          const y = parseFloat(numbers[i + 1]);\r\n          modifiedNumbers.push(\r\n            (isRelative ? x : x + offsetX).toString(),\r\n            (isRelative ? y : y + offsetY).toString()\r\n          );\r\n        }\r\n        break;\r\n      \r\n      case 'H':\r\n        // horizontal line (x coordinate only)\r\n        for (let i = 0; i < numbers.length; i++) {\r\n          const x = parseFloat(numbers[i]);\r\n          modifiedNumbers.push((isRelative ? x : x + offsetX).toString());\r\n        }\r\n        break;\r\n      \r\n      case 'V':\r\n        // vertical line (y coordinate only)\r\n        for (let i = 0; i < numbers.length; i++) {\r\n          const y = parseFloat(numbers[i]);\r\n          modifiedNumbers.push((isRelative ? y : y + offsetY).toString());\r\n        }\r\n        break;\r\n      \r\n      case 'C':\r\n        // cubic bezier (x1,y1 x2,y2 x,y)\r\n        for (let i = 0; i < numbers.length; i += 6) {\r\n          const x1 = parseFloat(numbers[i]);\r\n          const y1 = parseFloat(numbers[i + 1]);\r\n          const x2 = parseFloat(numbers[i + 2]);\r\n          const y2 = parseFloat(numbers[i + 3]);\r\n          const x = parseFloat(numbers[i + 4]);\r\n          const y = parseFloat(numbers[i + 5]);\r\n          modifiedNumbers.push(\r\n            (isRelative ? x1 : x1 + offsetX).toString(),\r\n            (isRelative ? y1 : y1 + offsetY).toString(),\r\n            (isRelative ? x2 : x2 + offsetX).toString(),\r\n            (isRelative ? y2 : y2 + offsetY).toString(),\r\n            (isRelative ? x : x + offsetX).toString(),\r\n            (isRelative ? y : y + offsetY).toString()\r\n          );\r\n        }\r\n        break;\r\n      \r\n      case 'S':\r\n      case 'Q':\r\n        // smooth cubic bezier or quadratic bezier (x1,y1 x,y)\r\n        for (let i = 0; i < numbers.length; i += 4) {\r\n          const x1 = parseFloat(numbers[i]);\r\n          const y1 = parseFloat(numbers[i + 1]);\r\n          const x = parseFloat(numbers[i + 2]);\r\n          const y = parseFloat(numbers[i + 3]);\r\n          modifiedNumbers.push(\r\n            (isRelative ? x1 : x1 + offsetX).toString(),\r\n            (isRelative ? y1 : y1 + offsetY).toString(),\r\n            (isRelative ? x : x + offsetX).toString(),\r\n            (isRelative ? y : y + offsetY).toString()\r\n          );\r\n        }\r\n        break;\r\n      \r\n      case 'A':\r\n        // arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)\r\n        for (let i = 0; i < numbers.length; i += 7) {\r\n          const rx = parseFloat(numbers[i]);\r\n          const ry = parseFloat(numbers[i + 1]);\r\n          const rotation = parseFloat(numbers[i + 2]);\r\n          const largeArc = parseFloat(numbers[i + 3]);\r\n          const sweep = parseFloat(numbers[i + 4]);\r\n          const x = parseFloat(numbers[i + 5]);\r\n          const y = parseFloat(numbers[i + 6]);\r\n          modifiedNumbers.push(\r\n            rx.toString(),\r\n            ry.toString(),\r\n            rotation.toString(),\r\n            largeArc.toString(),\r\n            sweep.toString(),\r\n            (isRelative ? x : x + offsetX).toString(),\r\n            (isRelative ? y : y + offsetY).toString()\r\n          );\r\n        }\r\n        break;\r\n      \r\n      default:\r\n        return match; // Unknown command, leave as is\r\n    }\r\n    \r\n    return command + modifiedNumbers.join(',');\r\n  });\r\n}\r\n\r\n// Random placement utility for non-overlapping bounding boxes with padding\r\nexport function randomlyPlacePaths(svg: SVGElement, paths: SVGPathElement[], padding: number = 20): SVGPathElement[] {\r\n  if (paths.length === 0) return paths;\r\n\r\n  const svgRect = svg.getBoundingClientRect();\r\n  const svgWidth = svgRect.width;\r\n  const svgHeight = svgRect.height;\r\n\r\n  // Calculate bounding boxes for all paths (before any modifications)\r\n  const pathBounds = paths.map(path => {\r\n    const bbox = path.getBBox();\r\n    return {\r\n      path,\r\n      width: bbox.width,\r\n      height: bbox.height,\r\n      originalBBox: bbox,\r\n      originalPathData: path.getAttribute('d') || ''\r\n    };\r\n  });\r\n\r\n  // Track placed positions to avoid overlaps\r\n  const placedBounds: Array<{ x: number; y: number; width: number; height: number }> = [];\r\n\r\n  // Function to check if a position would overlap with existing placements\r\n  function wouldOverlap(x: number, y: number, width: number, height: number): boolean {\r\n    return placedBounds.some(placed => {\r\n      return !(x + width + padding < placed.x ||\r\n               x > placed.x + placed.width + padding ||\r\n               y + height + padding < placed.y ||\r\n               y > placed.y + placed.height + padding);\r\n    });\r\n  }\r\n\r\n  // Function to find a valid random position\r\n  function findValidPosition(width: number, height: number, maxAttempts: number = 100): { x: number; y: number } | null {\r\n    for (let i = 0; i < maxAttempts; i++) {\r\n      const x = padding + Math.random() * (svgWidth - width - 2 * padding);\r\n      const y = padding + Math.random() * (svgHeight - height - 2 * padding);\r\n      \r\n      if (!wouldOverlap(x, y, width, height)) {\r\n        return { x, y };\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  // Place each path randomly by modifying its path data\r\n  pathBounds.forEach(({ path, width, height, originalBBox, originalPathData }) => {\r\n    const position = findValidPosition(width, height);\r\n    \r\n    if (position) {\r\n      // Calculate the offset needed to move the path to the new position\r\n      const offsetX = position.x - originalBBox.x;\r\n      const offsetY = position.y - originalBBox.y;\r\n      \r\n      // Modify the path data directly\r\n      const newPathData = translatePathData(originalPathData, offsetX, offsetY);\r\n      path.setAttribute('d', newPathData);\r\n      \r\n      // Record the placed bounds\r\n      placedBounds.push({\r\n        x: position.x,\r\n        y: position.y,\r\n        width,\r\n        height\r\n      });\r\n    } else {\r\n      // If we couldn't find a valid position, place it in a fallback location\r\n      console.warn('Could not find non-overlapping position for path, using fallback');\r\n      const fallbackX = padding + (placedBounds.length * 50) % (svgWidth - width - 2 * padding);\r\n      const fallbackY = padding + Math.floor((placedBounds.length * 50) / (svgWidth - width - 2 * padding)) * 60;\r\n      \r\n      const offsetX = fallbackX - originalBBox.x;\r\n      const offsetY = fallbackY - originalBBox.y;\r\n      \r\n      // Modify the path data directly\r\n      const newPathData = translatePathData(originalPathData, offsetX, offsetY);\r\n      path.setAttribute('d', newPathData);\r\n      \r\n      placedBounds.push({\r\n        x: fallbackX,\r\n        y: fallbackY,\r\n        width,\r\n        height\r\n      });\r\n    }\r\n  });\r\n\r\n  return paths;\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
